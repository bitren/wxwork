.class public Lcom/tencent/wework/setting/controller/HighLightTestActivity;
.super Landroid/app/Activity;
.source "HighLightTestActivity.java"


# instance fields
.field private mXN:Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;

.field private mXO:Z

.field private mXP:F

.field private mXQ:F

.field private textSize:F


# direct methods
.method public constructor <init>()V
    .locals 1

    .line 15
    invoke-direct {p0}, Landroid/app/Activity;-><init>()V

    const/4 v0, 0x0

    .line 19
    iput-boolean v0, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXO:Z

    return-void
.end method


# virtual methods
.method public bNy()V
    .locals 2

    const v0, 0x7f090004

    .line 33
    invoke-virtual {p0, v0}, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->findViewById(I)Landroid/view/View;

    move-result-object v0

    check-cast v0, Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;

    iput-object v0, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXN:Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;

    .line 34
    invoke-virtual {p0}, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->getResources()Landroid/content/res/Resources;

    move-result-object v0

    invoke-virtual {v0}, Landroid/content/res/Resources;->getDisplayMetrics()Landroid/util/DisplayMetrics;

    move-result-object v0

    iget v0, v0, Landroid/util/DisplayMetrics;->scaledDensity:F

    .line 35
    iget-object v1, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXN:Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;

    invoke-virtual {v1}, Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;->getTextSize()F

    move-result v1

    div-float/2addr v1, v0

    iput v1, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->textSize:F

    const/high16 v0, 0x41100000    # 9.0f

    .line 36
    iput v0, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXP:F

    const/high16 v0, 0x41b00000    # 22.0f

    .line 37
    iput v0, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXQ:F

    .line 38
    iget-object v0, p0, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->mXN:Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;

    const-string v1, "package com.tencent.wework.common.utils.SyntaxHighLight;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.os.Handler;\nimport android.text.Editable;\nimport android.text.InputFilter;\nimport android.text.Selection;\nimport android.text.Spannable;\nimport android.text.SpannableStringBuilder;\nimport android.text.Spanned;\nimport android.text.TextWatcher;\nimport android.text.method.ArrowKeyMovementMethod;\nimport android.text.method.MovementMethod;\nimport android.text.style.BackgroundColorSpan;\nimport android.text.style.ForegroundColorSpan;\nimport android.util.AttributeSet;\nimport android.view.GestureDetector;\nimport android.view.KeyEvent;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.EditText;\nimport android.widget.Scroller;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.CRC32;\n\npublic class SyntaxHighlightEditor extends android.support.v7.widget.AppCompatEditText implements EditTextInterface, View.OnKeyListener, GestureDetector.OnGestureListener {\n\n    public boolean SHOW_LINE_NUMBERS = true;\n    public boolean SYNTAX_HIGHLIGHTING = true;\n    public float TEXT_SIZE = 14;\n    public boolean WORDWRAP = false;\n    public boolean FLING_TO_SCROLL = true;\n\n    private Context mContext;\n    protected Paint mPaintNumbers;\n    protected Paint mPaintHighlight;\n    protected int mPaddingDP = 6;\n    protected int mPadding, mLinePadding;\n    protected float mScale;\n\n    protected Scroller mScroller;\n    protected GestureDetector mGestureDetector;\n    protected Point mMaxSize;\n\n    protected int mHighlightedLine;\n    protected int mHighlightStart;\n\n    protected Rect mDrawingRect, mLineBounds;\n\n    public interface OnTextChangedListener {\n        public void onTextChanged(String text);\n    }\n\n    public OnTextChangedListener onTextChangedListener = null;\n    public int updateDelay = 100;\n    public int errorLine = 0;\n    public boolean dirty = false;\n    private CRC32 mCRC32;\n\n    //Colors\n    private static final int COLOR_ERROR = 0x80ff0000;\n    private static final int COLOR_NUMBER = 0xffBC0000;\n    private static final int COLOR_KEYWORD = 0xff0096FF;\n    private static final int COLOR_BLTN = 0xff0046A5;\n    private static final int COLOR_COMMENT = 0xff009B00;\n    private static final int COLOR_BOOLEANS = 0xffBC0000;\n    private static final int COLOR_STRINGS = 0xffBC0000;\n\n    //Words\n    private static final Pattern line = Pattern.compile(\".*\\\\n\");\n    private static final Pattern booleans = Pattern.compile(\n\t\t\"\\\\b(true|false|null|undefined|boolean)\\\\b\");\n    private static final Pattern numbers = Pattern.compile(\n\t\t\"\\\\b(\\\\d*[.]?\\\\d+)\\\\b\");\n    private static final Pattern keywords = Pattern.compile(\n\t\t\"\\\\b(const|break|continue|Date|\"+\n\t\t\"do|for|while|if|else|in|out|this|\"+\n\t\t\"return|function|var|Math|Object|default|case|Array)\\\\b\");\n    private static final Pattern bltns = Pattern.compile(\n\t\t\"\\\\b(catch|try|sin|cos|log|sqrt|abs|floor|ceil|PI|length|equal|exec|find|next|\" +\n\t\t\"ModPE|Block|Entity|Item|Player|Server|Level|new|useItem|newLevel|match|\" +\n\t\t\"procCmd|chatHook|serverMessageReceiveHook|entityAddedHook|entityRemovedHook|\" +\n\t\t\"destroyBlock|attackHook|selectLevelHook|leaveGame|modTick|deathHook|startDestroyBlock|\" +\n\t\t\"blockEventHook|levelEventHook|chatReceiveHook|parseInt|run|ItemCathegory|ChatColor|ParticleType|\" +\n\t\t\"ArmorType|switch|pop|push|shift|sort|unshift|reverse|splice|concat|indexOf|join|lastIndexOf|slice|\" +\n\t\t\"toSource|toString|getText|valueOf|filter|every|map|some|forEach|acos|asin|atan|atan2|\" +\n\t\t\"max|min|random|round|exp|pow|tan|charAt|charCodeAt|replace|search|split|toLocaleTimeString|\" +\n\t\t\"toLowerCase|toUpperCase|eval|parseFloat|append|toArray|replaceAll|toPrecision|toUTCString|\" +\n\t\t\"toLocaleString|toExponential|toFixed|substring|substr|SQRT2|LN2|SQRT1_2|LOG10E|\" +\n\t\t\"LN10|LOG2E|LOG10E|caller|apply|constructor|arity|call|arguments|toLocaleDateString)\\\\b\");\n    private static final Pattern comments = Pattern.compile(\n\t\t\"/\\\\*(?:.|[\\\\n\\\\r])*?\\\\*/|//.*\" );\n    private static final Pattern symbols = Pattern.compile(\n\t\t\"[\\\\+\\\\-\\\\*\\\\^\\\\&\\\\?\\\\!\\\\=\\\\|\\\\<\\\\>\\\\:\\\\/]\");\n    private static final Pattern trailingWhiteSpace = Pattern.compile(\n\t\t\"[\\\\t ]+$\", Pattern.MULTILINE);\n    public static final Pattern general_strings = Pattern.compile(\"\\\"(.*?)\\\"|\'(.*?)\'\");\n\n    private final Handler updateHandler = new Handler();\n    private final Runnable updateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            Editable e = getText();\n            if(onTextChangedListener != null )\n                onTextChangedListener.onTextChanged(e.toString());\n            if(SYNTAX_HIGHLIGHTING)\n                highlightWithoutChange(e);\n        }\n    };\n\n    private boolean modified = true;\n\n    public SyntaxHighlightEditor(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        this.mContext = context;\n        mPaintNumbers = new Paint();\n        mPaintNumbers.setAntiAlias(true);\n        mPaintHighlight = new Paint();\n        mScale = context.getResources().getDisplayMetrics().density;\n        mPadding = (int) (mPaddingDP * mScale);\n        mHighlightedLine = mHighlightStart = -1;\n        mDrawingRect = new Rect();\n        mLineBounds = new Rect();\n        mGestureDetector = new GestureDetector(getContext(), this);\n        updateFromSettings();\n        init();\n    }\n\n    public void computeScroll() {\n        if (mScroller != null) {\n            if (mScroller.computeScrollOffset()) {\n                scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            }\n        } else {\n            super.computeScroll();\n        }\n    }\n\n    public void onDraw(Canvas canvas) {\n        int count, lineX, baseline;\n        count = getLineCount();\n        if (SHOW_LINE_NUMBERS) {\n            int padding = (int) (Math.floor(Math.log10(count)) + 1);\n            padding = (int) ((padding * mPaintNumbers.getTextSize()) + mPadding + (TEXT_SIZE * mScale * 0.5));\n            if (mLinePadding != padding) {\n                mLinePadding = padding;\n                setPadding(mLinePadding, mPadding, mPadding, mPadding);\n            }\n        }\n\n        getDrawingRect(mDrawingRect);\n        lineX = (int) (mDrawingRect.left + mLinePadding - (TEXT_SIZE * mScale * 0.5));\n        int min = 0;\n        int max = count;\n        getLineBounds(0, mLineBounds);\n        int startBottom = mLineBounds.bottom;\n        int startTop = mLineBounds.top;\n        getLineBounds(count - 1, mLineBounds);\n        int endBottom = mLineBounds.bottom;\n        int endTop = mLineBounds.top;\n        if (count > 1 && endBottom > startBottom && endTop > startTop) {\n            min = Math.max(min, ((mDrawingRect.top - startBottom) * (count - 1)) / (endBottom - startBottom));\n            max = Math.min(max, ((mDrawingRect.bottom - startTop) * (count - 1)) / (endTop - startTop) + 1);\n        }\n        for (int i = min; i < max; i++) {\n            baseline = getLineBounds(i, mLineBounds);\n            if ((mMaxSize != null) && (mMaxSize.x < mLineBounds.right)) {\n                mMaxSize.x = mLineBounds.right;\n            }\n            if ((i == mHighlightedLine) && (!WORDWRAP)) {\n                canvas.drawRect(mLineBounds, mPaintHighlight);\n            }\n            if (SHOW_LINE_NUMBERS) {\n                canvas.drawText(\"\" + (i + 1), mDrawingRect.left + mPadding, baseline, mPaintNumbers);\n            }\n            if (SHOW_LINE_NUMBERS) {\n                canvas.drawLine(lineX, mDrawingRect.top, lineX, mDrawingRect.bottom, mPaintNumbers);\n            }\n        }\n        getLineBounds(count - 1, mLineBounds);\n        if (mMaxSize != null) {\n            mMaxSize.y = mLineBounds.bottom;\n            mMaxSize.x = Math.max(mMaxSize.x + mPadding - mDrawingRect.width(), 0);\n            mMaxSize.y = Math.max(mMaxSize.y + mPadding - mDrawingRect.height(), 0);\n        }\n        super.onDraw(canvas);\n    }\n\n    public boolean onKey(View v, int keyCode, KeyEvent event) {\n        return false;\n    }\n\n    public boolean onTouchEvent(MotionEvent event) {\n        super.onTouchEvent(event);\n        if (mGestureDetector != null) {\n            return mGestureDetector.onTouchEvent(event);\n        }\n        return true;\n    }\n\n    public boolean onDown(MotionEvent e) {\n        return true;\n    }\n\n    public boolean onSingleTapUp(MotionEvent e) {\n        if (isEnabled()) {\n            ((InputMethodManager) getContext().getSystemService(\n\t\t        Context.INPUT_METHOD_SERVICE)).showSoftInput(this, InputMethodManager.SHOW_IMPLICIT);\n        }\n        return true;\n    }\n\n    public void onShowPress(MotionEvent e) {\n    }\n\n    public void onLongPress(MotionEvent e) {\n    }\n\n    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n        //mScroller.setFriction(0);\n        return true;\n    }\n\n    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\n        if (!FLING_TO_SCROLL) {\n            return true;\n        }\n        if (mScroller != null) {\n            mScroller.fling(getScrollX(), getScrollY(), -(int) velocityX,\n\t\t\t\t\t\t\t-(int) velocityY, 0, mMaxSize.x, 0, mMaxSize.y);\n        }\n        return true;\n    }\n\n    public void updateFromSettings() {\n        if (isInEditMode()) {\n            return;\n        }\n\n        setHorizontallyScrolling(WORDWRAP);\n        mPaintHighlight.setAlpha(48);\n        setTextSize(TEXT_SIZE);\n        mPaintNumbers.setTextSize(TEXT_SIZE * mScale * 0.85f);\n        postInvalidate();\n        refreshDrawableState();\n\n        if (FLING_TO_SCROLL) {\n            mScroller = new Scroller(getContext());\n            mMaxSize = new Point();\n        } else {\n            mScroller = null;\n            mMaxSize = null;\n        }\n\n        mLinePadding = mPadding;\n        int count = getLineCount();\n        if (SHOW_LINE_NUMBERS) {\n            mLinePadding = (int) (Math.floor(Math.log10(count)) + 1);\n            mLinePadding = (int) ((mLinePadding * mPaintNumbers.getTextSize())\n\t\t\t\t+ mPadding + (TEXT_SIZE * mScale * 0.5));\n            setPadding(mLinePadding, mPadding, mPadding, mPadding);\n        } else {\n            setPadding(mPadding, mPadding, mPadding, mPadding);\n        }\n    }\n\n    @Override\n    protected boolean getDefaultEditable() {\n        return true;\n    }\n\n    @Override\n    protected MovementMethod getDefaultMovementMethod() {\n        return ArrowKeyMovementMethod.getInstance();\n    }\n\n    @Override\n    public Editable getText() {\n        return (Editable) super.getText();\n    }\n\n    @Override\n    public void setText(CharSequence text, BufferType type) {\n        super.setText(text, BufferType.EDITABLE);\n    }\n\n    public void setSelection(int start, int stop) {\n        Selection.setSelection(getText(), start, stop);\n    }\n\n    public void setSelection(int index) {\n        Selection.setSelection(getText(), index);\n    }\n\n    public void selectAll() {\n        Selection.selectAll(getText());\n    }\n\n    public void extendSelection(int index) {\n        Selection.extendSelection(getText(), index);\n    }\n\n    public void setTextHighlighted(CharSequence text) {\n        cancelUpdate();\n        errorLine = 0;\n        dirty = false;\n        modified = false;\n        setText(highlight(new SpannableStringBuilder(text)));\n        modified = true;\n        if(onTextChangedListener != null )\n            onTextChangedListener.onTextChanged(text.toString());\n    }\n\n    public String getCleanText() {\n        return trailingWhiteSpace.matcher(getText()).replaceAll(\"\");\n    }\n\n    public void refresh() {\n        highlightWithoutChange(getText());\n    }\n\n    @Override\n    public void init() {\n        mCRC32 = new CRC32();\n        setFilters(new InputFilter[]{\n\t\t       new InputFilter() {\n\t\t\t\t@Override\n\t\t\t\tpublic CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\t\t\t\t\tif(modified &&\n\t\t\t\t\t\tend-start == 1 &&\n\t\t\t\t\t\tstart < source.length() &&\n\t\t\t\t\t\tdstart < dest.length()) {\n\t\t\t\t\t\tchar c = source.charAt(start);\n\t\t\t\t\t\tif(c == \'\\n\')\n\t\t\t\t\t\t\treturn autoIndent(source, start, end, dest, dstart, dend);\n\t\t\t\t\t}\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\t\t\t}\n        });\n\n        addTextChangedListener(new TextWatcher() {\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable e) {\n\t\t\tcancelUpdate();\n\t\t\tif(!modified)\n\t\t\t\treturn;\n\t\t\tdirty = true;\n\t\t\tupdateHandler.postDelayed(updateRunnable, updateDelay );\n\t\t}\n\t});\n    }\n\n    @Override\n    public void show() {\n        setVisibility(View.VISIBLE);\n    }\n\n    @Override\n    public void hide() {\n        setVisibility(View.GONE);\n    }\n\n    @Override\n    public String getString() {\n        String text = \"\";\n        try {\n            text = getText().toString();\n        }catch (OutOfMemoryError e) {\n        }\n        return text;\n    }\n\n    private int mOldTextlength = 0;\n    private long mOldTextCrc32 = 0;\n\n    @Override\n    public void updateTextFinger() {\n        mOldTextlength = getText().length();\n        byte bytes[] = getString().getBytes();\n        mCRC32.reset();\n        mCRC32.update(bytes, 0, bytes.length);\n        mOldTextCrc32 = mCRC32.getValue();\n    }\n\n    @Override\n    public boolean isTextChanged() {\n        CharSequence text = getText();\n        int hash = text.length();\n        if(mOldTextlength != hash){\n            return true;\n        }\n        mCRC32.reset();\n        byte bytes[] = getString().getBytes();\n        mCRC32.update(bytes, 0, bytes.length);\n        return mOldTextCrc32 != mCRC32.getValue();\n    }\n\n    private void cancelUpdate() {\n        updateHandler.removeCallbacks(updateRunnable);\n    }\n\n    private void highlightWithoutChange(Editable e) {\n        modified = false;\n        highlight(e);\n        modified = true;\n    }\n\n    private Editable highlight(Editable e) {\n        try {\n                clearSpans(e);\n                if(e.length() == 0)\n                    return e;\n                if(errorLine > 0) {\n                Matcher m = line.matcher(e);\n                \n                for(int n = errorLine; n-- > 0 && m.find(););\n                e.setSpan(\n\t\t\tnew BackgroundColorSpan(COLOR_ERROR),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n                for(Matcher m = numbers.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_NUMBER),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n\t\tfor(Matcher m = keywords.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_KEYWORD),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n                for(Matcher m = bltns.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_BLTN),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n                for(Matcher m = booleans.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_BOOLEANS),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n                for(Matcher m = symbols.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_COMMENT),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n                for(Matcher m = comments.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_COMMENT),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n                for(Matcher m = general_strings.matcher(e); m.find();)\n                e.setSpan(\n\t\t\tnew ForegroundColorSpan(COLOR_STRINGS),\n\t\t\tm.start(),\n\t\t\tm.end(),\n\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            } catch(Exception ex) {\n        }\n        return e;\n    }\n\n    private void clearSpans(Editable e){\n\t{\n            ForegroundColorSpan spans[] = e.getSpans(\n\t\t\t0, e.length(), ForegroundColorSpan.class);\n            for(int n = spans.length; n-- > 0;)\n                e.removeSpan(spans[n]);\n        }\n\n        {\n            BackgroundColorSpan spans[] = e.getSpans(0, e.length(), BackgroundColorSpan.class);\n            for(int n = spans.length; n-- > 0;)\n                e.removeSpan(spans[n]);\n        }\n    }\n\n    private CharSequence autoIndent(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n        String indent = \"\";\n        int istart = dstart-1;\n        int iend = -1;\n        boolean dataBefore = false;\n        int pt = 0;\n\n        for(; istart > -1; --istart) {\n            char c = dest.charAt(istart);\n            if(c == \'\\n\')\n                break;\n            if(c != \' \' && c != \'\\t\') {\n                if(!dataBefore) {\n                    if(c == \'{\' ||\n\t\t\tc == \'+\' ||\n\t\t\tc == \'-\' ||\n\t\t\tc == \'*\' ||\n\t\t\tc == \'/\' ||\n\t\t\tc == \'%\' ||\n\t\t\tc == \'^\' ||\n\t\t\tc == \'=\')\n                        --pt;\n                    dataBefore = true;\n                }\n                if(c == \'(\')\n                    --pt;\n                else if(c == \')\')\n                    ++pt;\n            }\n        }\n        if(istart > -1) {\n            char charAtCursor = dest.charAt(dstart);\n            for(iend = ++istart; iend < dend; ++iend) {\n                char c = dest.charAt(iend);\n                if(charAtCursor != \'\\n\' && c == \'/\' && iend+1 < dend && dest.charAt(iend) == c) {\n                    iend += 2;\n                    break;\n                }\n                if(c != \' \' && c != \'\\t\')\n                    break;\n            }\n            indent += dest.subSequence(istart, iend);\n        }\n        if(pt < 0)\n            indent += \"\\t\";\n        return source+indent;\n    }\n}\n"

    invoke-virtual {v0, v1}, Lcom/tencent/wework/common/views/codeview/SyntaxHighlightEditor;->ay(Ljava/lang/CharSequence;)V

    return-void
.end method

.method protected onCreate(Landroid/os/Bundle;)V
    .locals 0

    .line 27
    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

    const p1, 0x7f0c00c4

    .line 28
    invoke-virtual {p0, p1}, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->setContentView(I)V

    .line 29
    invoke-virtual {p0}, Lcom/tencent/wework/setting/controller/HighLightTestActivity;->bNy()V

    return-void
.end method
